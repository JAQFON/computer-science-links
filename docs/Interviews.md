Big O 
  Analysis of an algorithms efficiency
  Complexity in terms of input size (N)
  Machine independent
  Analysis of time and space
  Usually measures worst case 
Rules
Ignores constants
  Certain terms “dominate” 
  O(1) < O(logn) < O(n) < O(nLogn) < O (n2) < O(2n) < O(n!)
  “Ignore low-order terms”
  Greatest term dominates i.e. O(1) will be dominated by O(2n)
  How to code linked list X
  Looped through linked list X
  Length or any point of linked list  X
Learn sorting algo (no bubble) 
  Quick sort
  Merge sort (usua
Searching ( pre order, in order, post order ) - practice more 
Algorithm to count words X
Counting words, palindrome 
Practice BigO for each type of data structure (hash map, linked list, BST)
